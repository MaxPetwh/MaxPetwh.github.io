#ifndef _TEST_H_     //在做大项目时，为了避免重新包含头文件而加的判断
#define _TEST_H_


#endif

static静态效果，如果你想让别人调用接口而不得到调用文件内部的数据，则对数据前面加一个static 
static void test(){
  数据
}
void test_printf(){
  int time = 0;    //你加static，每次进入函数都重新执行time = 0，数只加一次
  static int time = 0;     //加了static的话就只执行一次，数会累加
  time ++;
  test();
}
调用的时候将数据直接调用test_printf()这个函数既可以


define与typedef区别

typedef char * zhizhen1;
#define zhizhen2 char *

zhizhen1 c1,c2;     /*c1,c2 都为char*,typedef为char*引入一个新的别名 */
zhizhen2 c3,c4;     /*char *c3,c4;c3为指针类型,  而c4为char类型*/


#define NET_INIT 1
#define NET_CONNECT_ING 2
#define NET_CONNECT_SUCCESS 3
#define NET_CONNECT_FAIL 4

typedef enum{
  NET_INIT 1,
  NET_CONNECT_ING,
  NET_CONNECT_SUCCESS,
  NET_CONNECT_FAIL,
  NET_ERROR,
}E_NET_STATUS;
enum的作用是枚举，在使用这个枚举命名后，使用E_NET_STATUS时只能使用这个枚举内部的提供的数据，输入其他非枚举内的数据都不会响应



struct结构体
typedef struct{
  int system_status;
  E_NET_STATUS net_status;
  int motor_status[4];
  int pay_status;
}T_D

//初始化一个结构体变量
T_D g_D;
T_D g_D1;

void main(){
  g_D.net_status = NET_INIT;
  g_D_1.net_status = NET_CONNECT_ING;
  printf ("Net status = %d\n",g_D.net_status);
  printf ("Net1 status = %d\n",g_D_1.net_status);
}



//va_list()的使用
//va_list的说明：是在C语言中定义的宏,解决问题
//变参问题是指参数的个数不定，可以是传入一个参数也可以是多个;
//可变参数中的每个参数的类型可以不同,也可以相同;
//可变参数的每个参数并没有实际的名称与之相对应。

//用法：#include <stdarg.h>
//void test_1(char *fmt,...){
  va_list arg1;  //首先定义函数va_list的变量
  va_start(arg1,fmt);  //然后用va_start宏初始化变量刚定义的va_list变量；
  printf(" %d \n",va_arg(arg1,int));  //va_arg返回可变的参数，va_arg的第二个参数是你要返回的参数的类型
  printf(" %d \n",va_arg(arg1,int));
  printf(" %d \n",va_arg(arg1,int));  //第三个值因为没有定义所以返回指针所指地址
  va_end(arg1);//最后用va_end宏结束可变参数的获取
}

void main(){
    int a = 10,b = 11;
    printf("app start1\n");
    //printf("%d \n",a);
    test_1("",a,b);
    //返回的结果为：app start1
                   10
                   11
                   4201152
}
    
    
    
    
    
 void EM_LOG(const char *fmt,...){
    va_list arg;
    va_start(arg,fmt);
    char buf[1+vsnprintf(NULL,0,fmt,arg)];  //！！这里加
    vsnprintf(buf,sizeof(buf),fmt,arg);
    va_end(arg);
    printf("%s\n",buf);
}

void main(){
    int a = 10,b = 11;
    EM_LOG("app start");
}    //输出的结果为：app star  没有t,因为不止把常变参数传进去外还附加入了结束符所以会多占一位输出的结果少一个,在char buf 里vsnprintf 加1才能显示完整的输出结果
    


//printf,fprintf,vsnprintf的区别  printf是将输出结果打印出来,fprintf是将日志信息打印到文件里去,vsnprintf是日志打印到命名的函数里去
vsnprintf函数
头文件：#include  <stdarg.h>
函数原型：int vsnprintf(char *str, size_t size, const char *format, va_list ap);
函数说明：将可变参数格式化输出到一个字符数组
参数：
str输出到的数组，size指定大小，防止越界，format格式化参数，ap可变参数列表函数用法
#include <stdio.h>
#include <stdarg.h>
 
void SYSTEM(const char * format, ...)
{
	char buff[4069];
	va_list list;
	va_start(list, format);
	vsnprintf(buff, 4069, format, list);
	va_end(list);
	printf("%s\n", buff);
}
 
void main()
{
	SYSTEM("%d_%s", 6, "abc");
}










