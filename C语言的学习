#ifndef _TEST_H_     //在做大项目时，为了避免重新包含头文件而加的判断
#define _TEST_H_


#endif

static静态效果，如果你想让别人调用接口而不得到调用文件内部的数据，则对数据前面加一个static 
static void test(){
  数据
}
void test_printf(){
  int time = 0;    //你加static，每次进入函数都重新执行time = 0，数只加一次
  static int time = 0;     //加了static的话就只执行一次，数会累加
  time ++;
  test();
}
调用的时候将数据直接调用test_printf()这个函数既可以


define与typedef区别

typedef char * zhizhen1;
#define zhizhen2 char *

zhizhen1 c1,c2;     /*c1,c2 都为char*,typedef为char*引入一个新的别名 */
zhizhen2 c3,c4;     /*char *c3,c4;c3为指针类型,  而c4为char类型*/


#define NET_INIT 1
#define NET_CONNECT_ING 2
#define NET_CONNECT_SUCCESS 3
#define NET_CONNECT_FAIL 4

typedef enum{
  NET_INIT 1,
  NET_CONNECT_ING,
  NET_CONNECT_SUCCESS,
  NET_CONNECT_FAIL,
  NET_ERROR,
}E_NET_STATUS;
enum的作用是枚举，在使用这个枚举命名后，使用E_NET_STATUS时只能使用这个枚举内部的提供的数据，输入其他非枚举内的数据都不会响应



struct结构体
typedef struct{
  int system_status;
  E_NET_STATUS net_status;
  int motor_status[4];
  int pay_status;
}T_D

//初始化一个结构体变量
T_D g_D;
T_D g_D1;

void main(){
  g_D.net_status = NET_INIT;
  g_D_1.net_status = NET_CONNECT_ING;
  printf ("Net status = %d\n",g_D.net_status);
  printf ("Net1 status = %d\n",g_D_1.net_status);
}













